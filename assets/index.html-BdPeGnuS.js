import{_ as n,c as a,a as r,b as d,d as t,w as l,r as s,o as c,e as i}from"./app-BVpc6fz1.js";const u={},p={class:"table-of-contents"};function k(h,e){const o=s("router-link");return c(),a("div",null,[r("nav",p,[r("ul",null,[r("li",null,[t(o,{to:"#_1-docker-vs-虚拟机"},{default:l(()=>e[0]||(e[0]=[i("1. Docker vs 虚拟机")])),_:1})]),r("li",null,[t(o,{to:"#_2-docker-的优势"},{default:l(()=>e[1]||(e[1]=[i("2. Docker 的优势")])),_:1}),r("ul",null,[r("li",null,[t(o,{to:"#_2-1-资源利用率高"},{default:l(()=>e[2]||(e[2]=[i("2.1 资源利用率高")])),_:1})]),r("li",null,[t(o,{to:"#_2-2-快速部署"},{default:l(()=>e[3]||(e[3]=[i("2.2 快速部署")])),_:1})]),r("li",null,[t(o,{to:"#_2-3-环境一致性"},{default:l(()=>e[4]||(e[4]=[i("2.3 环境一致性")])),_:1})]),r("li",null,[t(o,{to:"#_2-4-持续交付与部署"},{default:l(()=>e[5]||(e[5]=[i("2.4 持续交付与部署")])),_:1})]),r("li",null,[t(o,{to:"#_2-5-易于迁移"},{default:l(()=>e[6]||(e[6]=[i("2.5 易于迁移")])),_:1})]),r("li",null,[t(o,{to:"#_2-6-维护与扩展"},{default:l(()=>e[7]||(e[7]=[i("2.6 维护与扩展")])),_:1})]),r("li",null,[t(o,{to:"#对比传统虚拟机"},{default:l(()=>e[8]||(e[8]=[i("对比传统虚拟机")])),_:1})])])]),r("li",null,[t(o,{to:"#_3-docker-核心概念"},{default:l(()=>e[9]||(e[9]=[i("3. Docker 核心概念")])),_:1}),r("ul",null,[r("li",null,[t(o,{to:"#_3-1-docker-镜像"},{default:l(()=>e[10]||(e[10]=[i("3.1 Docker 镜像")])),_:1})])])]),r("li",null,[t(o,{to:"#docker-容器-container"},{default:l(()=>e[11]||(e[11]=[i("Docker 容器（Container）")])),_:1})]),r("li",null,[t(o,{to:"#docker-registry"},{default:l(()=>e[12]||(e[12]=[i("Docker Registry")])),_:1}),r("ul",null,[r("li",null,[t(o,{to:"#docker-registry公开服务"},{default:l(()=>e[13]||(e[13]=[i("Docker Registry公开服务")])),_:1})]),r("li",null,[t(o,{to:"#私有-docker-registry"},{default:l(()=>e[14]||(e[14]=[i("私有 Docker Registry")])),_:1})])])])])]),e[15]||(e[15]=d('<hr><p>Docker 是由 dotCloud 公司创始人 Solomon Hykes 发起的开源项目，使用 Go 语言开发。它基于 Linux 内核的 cgroup、namespace 以及 UnionFS 等技术，实现了操作系统层面的虚拟化。Docker 通过对进程进行封装和隔离，将其变成可移植的<strong>容器</strong>，大大简化了应用的部署和维护。</p><h2 id="_1-docker-vs-虚拟机" tabindex="-1"><a class="header-anchor" href="#_1-docker-vs-虚拟机"><span>1. Docker vs 虚拟机</span></a></h2><ul><li><strong>虚拟机</strong>：通过虚拟化一套完整的硬件系统，在其上运行独立的操作系统</li><li><strong>容器</strong>：直接使用宿主机的内核，只隔离应用程序的运行环境</li><li><strong>优势</strong>：容器更轻量、启动更快、资源利用率更高</li></ul><h2 id="_2-docker-的优势" tabindex="-1"><a class="header-anchor" href="#_2-docker-的优势"><span>2. Docker 的优势</span></a></h2><h3 id="_2-1-资源利用率高" tabindex="-1"><a class="header-anchor" href="#_2-1-资源利用率高"><span>2.1 资源利用率高</span></a></h3><ul><li>无需硬件虚拟化，系统开销小</li><li>应用执行速度快，内存占用少</li><li>存储效率高，可运行更多应用</li></ul><h3 id="_2-2-快速部署" tabindex="-1"><a class="header-anchor" href="#_2-2-快速部署"><span>2.2 快速部署</span></a></h3><ul><li>秒级启动，远快于虚拟机</li><li>简化开发测试流程</li><li>提高部署效率</li></ul><h3 id="_2-3-环境一致性" tabindex="-1"><a class="header-anchor" href="#_2-3-环境一致性"><span>2.3 环境一致性</span></a></h3><ul><li>镜像封装完整运行环境</li><li>避免环境差异导致的问题</li><li>统一开发、测试、生产环境</li></ul><h3 id="_2-4-持续交付与部署" tabindex="-1"><a class="header-anchor" href="#_2-4-持续交付与部署"><span>2.4 持续交付与部署</span></a></h3><ul><li>支持 DevOps 实践</li><li>通过 Dockerfile 构建镜像</li><li>自动化部署和测试</li><li>透明的构建过程</li></ul><h3 id="_2-5-易于迁移" tabindex="-1"><a class="header-anchor" href="#_2-5-易于迁移"><span>2.5 易于迁移</span></a></h3><ul><li>跨平台运行一致性</li><li>支持多种运行环境</li><li>简化应用迁移流程</li></ul><h3 id="_2-6-维护与扩展" tabindex="-1"><a class="header-anchor" href="#_2-6-维护与扩展"><span>2.6 维护与扩展</span></a></h3><ul><li>分层存储便于复用</li><li>简化更新维护</li><li>丰富的官方镜像</li></ul><h3 id="对比传统虚拟机" tabindex="-1"><a class="header-anchor" href="#对比传统虚拟机"><span>对比传统虚拟机</span></a></h3><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="_3-docker-核心概念" tabindex="-1"><a class="header-anchor" href="#_3-docker-核心概念"><span>3. Docker 核心概念</span></a></h2><p>Docker 的三个基本概念：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><h3 id="_3-1-docker-镜像" tabindex="-1"><a class="header-anchor" href="#_3-1-docker-镜像"><span>3.1 Docker 镜像</span></a></h3><p>镜像是一个只读的文件系统模板，包含了运行应用所需的所有文件和配置。例如，<code>ubuntu:18.04</code> 镜像包含了完整的 Ubuntu 18.04 最小系统。</p><h4 id="分层存储" tabindex="-1"><a class="header-anchor" href="#分层存储"><span>分层存储</span></a></h4><p>Docker 采用分层存储架构：</p><ul><li>利用 UnionFS 技术实现</li><li>镜像由多个层组成</li><li>每层只记录差异部分</li><li>可以共享和复用层</li></ul><h2 id="docker-容器-container" tabindex="-1"><a class="header-anchor" href="#docker-容器-container"><span>Docker 容器（Container）</span></a></h2><p>镜像（Image）与容器（Container）的关系，就像是面向对象程序设计中的<code>类</code>和<code>示例</code>一样,镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建，启动，停止，删除，暂停等等。<br> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的<code>命名空间</code>。因此容器可以拥有自己的<code>root</code>文件系统、自己的网络配置，自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学Docker时会混淆容器和虚拟机。<br> 镜像使用的是分层存储，容器也是。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个为容器运行时读写而准备的存储层为容器存储层。<br> 容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br> 按Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器岑储层要保持无状态化。所有的文件写入操作，都应该使用<code>数据卷</code>，或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网路存储）发生读写，其性能和稳定性更高。<br> 是数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据不会丢失</p><h2 id="docker-registry" tabindex="-1"><a class="header-anchor" href="#docker-registry"><span>Docker Registry</span></a></h2><p>镜像构建完成后，可以容易的在当前宿主机上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储，分发镜像的服务，Docker Registry就是这样的服务<br> 一个 <code>Docker Registry</code>中可以包含多个<code>仓库</code>（Repository）；每个仓库可以包含多个<code>标签</code>（Tag）；每个标签对应一个镜像<br> 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。<br> 以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04, 18.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 两段式路径 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务</p><h3 id="docker-registry公开服务" tabindex="-1"><a class="header-anchor" href="#docker-registry公开服务"><span>Docker Registry公开服务</span></a></h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。</p><p>国内有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。</p><h3 id="私有-docker-registry" tabindex="-1"><a class="header-anchor" href="#私有-docker-registry"><span>私有 Docker Registry</span></a></h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。</p>',41))])}const D=n(u,[["render",k],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/linux/xdeph961/","title":"01. 什么是Docker","lang":"zh-CN","frontmatter":{"createTime":"2025/02/17 16:59:04","permalink":"/linux/xdeph961/","title":"01. 什么是Docker","description":"Docker 是由 dotCloud 公司创始人 Solomon Hykes 发起的开源项目，使用 Go 语言开发。它基于 Linux 内核的 cgroup、namespace 以及 UnionFS 等技术，实现了操作系统层面的虚拟化。Docker 通过对进程进行封装和隔离，将其变成可移植的容器，大大简化了应用的部署和维护。 1. Docker vs ...","head":[["meta",{"property":"og:url","content":"https://notes.moniter.top/linux/xdeph961/"}],["meta",{"property":"og:site_name","content":"Richie Lin"}],["meta",{"property":"og:title","content":"01. 什么是Docker"}],["meta",{"property":"og:description","content":"Docker 是由 dotCloud 公司创始人 Solomon Hykes 发起的开源项目，使用 Go 语言开发。它基于 Linux 内核的 cgroup、namespace 以及 UnionFS 等技术，实现了操作系统层面的虚拟化。Docker 通过对进程进行封装和隔离，将其变成可移植的容器，大大简化了应用的部署和维护。 1. Docker vs ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01. 什么是Docker\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"git":{},"autoDesc":true,"filePathRelative":"notes/linux/Kubernetes/Docker系列学习/Docker系列学习-01.Docker介绍.md"}');export{D as comp,y as data};
