import{_ as l,c,a,b as t,d as e,w as n,r as d,o as h,e as p}from"./app-BVpc6fz1.js";const k={},r={class:"table-of-contents"};function o(g,s){const i=d("router-link");return h(),c("div",null,[a("nav",r,[a("ul",null,[a("li",null,[e(i,{to:"#from指定基础镜像"},{default:n(()=>s[0]||(s[0]=[p("FROM指定基础镜像")])),_:1})]),a("li",null,[e(i,{to:"#run执行命令"},{default:n(()=>s[1]||(s[1]=[p("RUN执行命令")])),_:1})]),a("li",null,[e(i,{to:"#构建镜像"},{default:n(()=>s[2]||(s[2]=[p("构建镜像")])),_:1})]),a("li",null,[e(i,{to:"#镜像构建上下文-context"},{default:n(()=>s[3]||(s[3]=[p("镜像构建上下文(Context)")])),_:1})]),a("li",null,[e(i,{to:"#其他docker-build的用法"},{default:n(()=>s[4]||(s[4]=[p("其他docker build的用法")])),_:1}),a("ul",null,[a("li",null,[e(i,{to:"#直接用-git-repo进行构建"},{default:n(()=>s[5]||(s[5]=[p("直接用 Git repo进行构建")])),_:1})]),a("li",null,[e(i,{to:"#用给定的tar压缩包构建"},{default:n(()=>s[6]||(s[6]=[p("用给定的tar压缩包构建")])),_:1})]),a("li",null,[e(i,{to:"#从标准输入中读取dockerfile进行构建"},{default:n(()=>s[7]||(s[7]=[p("从标准输入中读取Dockerfile进行构建")])),_:1})]),a("li",null,[e(i,{to:"#从标准输入中读取上下文压缩包进行构建"},{default:n(()=>s[8]||(s[8]=[p("从标准输入中读取上下文压缩包进行构建")])),_:1})])])])])]),s[9]||(s[9]=t(`<hr><p><strong>前言</strong> 刚开始使用的是<code>docker commit</code>在定制镜像。<br> 镜像定制实际上就是定制每一层所添加的配置、文件。当我们把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题，镜像构建透明性的问题，体积的问题都会解决，这个脚本就是<code>Dockfile</code><code>Dockerfile</code>是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>以定制<code>nginx</code>镜像为例，我们使用Dockerfile来定制</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">##</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">在一个空白目录中，建立一个文本文件，命令为Dockerfile</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">mkdir</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">mynginx</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">cd</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">mynginx</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">touch</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Dockerfile</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">FROM</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">nginx</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">echo</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">&lt;h1&gt;Hello,Docker!&lt;/h1&gt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/share/nginx/html/index.html</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">##</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">说明：这个Dockerfile很简单，一共两行，涉及两条指令，FROM和RUN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="from指定基础镜像" tabindex="-1"><a class="header-anchor" href="#from指定基础镜像"><span>FROM指定基础镜像</span></a></h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像之前运行一个nginx镜像的容器，在进行修改，基础镜像是必须指定的。<br> 而<code>FROM</code>：是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p><p>在Docker Hub上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如<code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>php</code>、<code>tomcat</code>等；也有一些方便开发，构建，运行各种语言应用的镜像，如<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>golang</code>等。可以在其中寻找符合最终目标的镜像为基础镜像进行定制</p><p>没有找到对应服务的镜像，官方镜像提供了一些更为基础的操作系统镜像，如<code>ubuntu</code>、<code>centos</code>、<code>debian</code>、<code>fedora</code>、<code>alpine</code>等，这些操作系统的软件库提供了广阔的扩展空间</p><p>除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，表示一个空白的镜像</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>FROM</span><span class="space"> </span><span>sreatch</span></span>
<span class="line"><span>···</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当以scratch为基础镜像的话，意味着不以任何镜像为基础，接下来的所有指令将作为镜像第一层存在。</p><h2 id="run执行命令" tabindex="-1"><a class="header-anchor" href="#run执行命令"><span>RUN执行命令</span></a></h2><p><code>RUN</code>指令是用来执行命令行命令的。由于命令行的能力，<code>RUN</code>指令在定制镜像时时最常用的指令之一。其格式有两种：</p><ul><li>shell格式：<code>RUN &lt;命令&gt;</code>,就像直接在命令行中输入的命令一样。比如：</li></ul><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">echo</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">&lt;h1&gt;Hello,Docker!&lt;/h1&gt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/share/nginx/html/index.html</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>exec格式：\`\`RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]，这更像是函数调用中的格式<br> 既然RUN就像shell脚本一样可以执行命令，是否可以向shell脚本一样把每个命令对应一个RUN</li></ul><div class="language-yaml line-numbers-mode" data-ext="yaml" data-title="yaml"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">FROM</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">debian:stretch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apt-get</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">update</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apt-get</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">install</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-y</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gcc</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">libc6-dev</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">make</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">wget</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">wget</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-O</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">redis.tar.gz</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">mkdir</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-p</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">tar</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-xzf</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">redis.tar.gz</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-C</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">--strip-components=1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**说明：**由于Dockerfile中每一个指令都会建立一层，<code>RUN</code>也不例外，每一个<code>RUN</code>的行为，就和我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。<br> 上面的写法，创建了5层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em><strong>Union FS是有最大层数限制的，比如AUFS，曾经是最大不超过42层，现在是不得超过127层。</strong></em> 上面的<code>Dockerfile</code>正确的写法：</p><div class="language-yaml line-numbers-mode" data-ext="yaml" data-title="yaml"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">FROM</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">debian:stretch</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">RUN</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">buildDeps=&#39;gcc</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">libc6-dev</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">make</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">wget&#39;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apt-get</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">update</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apt-get</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">install</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-y</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">$buildDeps</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">wget</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-O</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">redis.tar.gz</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">mkdir</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-p</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">tar</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-xzf</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">redis.tar.gz</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-C</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">--strip-components=1</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">make</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-C</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">make</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-C</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">install</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">rm</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-rf</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/var/lib/apt/lists/*</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">rm</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">redis.tar.gz</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">rm</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-r</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/usr/src/redis</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\\</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">&amp;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apt-get</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">purge</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-y</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">--auto-remove</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">$buildDeps</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：<strong>之前的所有命令只有一个目的，就是编译、安装redis可执行文件。所以没有比较建立很多层，只需要在一层中完成。因此，仅仅使用一个RUN指令，并使用&amp;&amp;将各个所需命令串联起来。<br> 并且，这里为了格式化还进行了换行。Dockerfile支持Shell类的行尾添加<code>\\</code>的命令换行方式，以及行首<code>#</code>进行注释的格式。<br> 在这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件、并且清理了<code>apt</code>缓存文件。这是</strong>比较重要</strong>的一步。镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着进项。因此镜像构建上，一定要确保每一层添加需要添加的东西，无关的东西应该清理掉。</p><h2 id="构建镜像" tabindex="-1"><a class="header-anchor" href="#构建镜像"><span>构建镜像</span></a></h2><p>明白了Dockerfile的内容，现在进行构建镜像。<br> 在<code>Dockerfile</code>文件所在目录执行：</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-t</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">nginx:v2</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>这里使用 <code>docker build</code>命令进行镜像构建。格式： docker build [选项] &lt;上下文路径/URL/-&gt;</li><li>在这里，指定了最终的镜像名称 -t nginx:v2 构建成功后，可以像之前运行nginx:v2那样来运行这个镜像。</li></ul><h2 id="镜像构建上下文-context" tabindex="-1"><a class="header-anchor" href="#镜像构建上下文-context"><span>镜像构建上下文(Context)</span></a></h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个<code>.</code>。<br> . 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<code>上下文路径</code>。那么什么是上下文呢？</p><p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 <code>Docker 引擎</code>（也就是服务端守护进程）和<code>客户端工具</code>。<code>Docker</code> 的引擎提供了一组 <code>REST AP</code>I，被称为 <code>Docker Remote API</code>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <code>API</code> 与 <code>Docker</code> 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 <code>C/S</code> 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br> 当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种<code>客户端/服务端</code>的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <code>Docker 引擎</code>。这样 <code>Docker 引擎</code>收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在<code>dockerfile</code>中这么写：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>COPY</span><span class="space"> </span><span>./package.json</span><span class="space"> </span><span>/app/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>着并不是要复制执行，<code>docker build</code>命令所在的目录下的<code>package.json</code>，也不是复制<code>Dockerfile</code>所在目录下的<code>package.json</code>，而是复制**上下文（context）**目录下的<code>package.json</code><br> 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者<code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去</p><p><strong>理解构建上下文</strong>对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者<strong>项目根目录</strong>下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个<code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br> 那么为什么会有人误以为 <code>.</code>是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code>的文件作为<code>Dockerfile</code>。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h2 id="其他docker-build的用法" tabindex="-1"><a class="header-anchor" href="#其他docker-build的用法"><span>其他<code>docker build</code>的用法</span></a></h2><h3 id="直接用-git-repo进行构建" tabindex="-1"><a class="header-anchor" href="#直接用-git-repo进行构建"><span>直接用 Git repo进行构建</span></a></h3><p><code>docker build</code>还支持从URL构建，比如可以直接从Git repo中构建:</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">https://github.com/twang2218/gitlab-ce-zh.git#:11.1</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">这行命令指定了构建所需的Git</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">repo，并且指定默认的master分支，构建目录为/11.1/，然后Docker就会自己去git</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">clone这个项目，切换到指定分支，并进入到指定目录后开始创建</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="用给定的tar压缩包构建" tabindex="-1"><a class="header-anchor" href="#用给定的tar压缩包构建"><span>用给定的tar压缩包构建</span></a></h3><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">https://server/context.tar.gz</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果给出的URL不是个git reop，而是个<code>tar</code>压缩包，那么Docker引擎会下载这个包，并自动解压缩，以其作为上下文。开始构建。</p><h3 id="从标准输入中读取dockerfile进行构建" tabindex="-1"><a class="header-anchor" href="#从标准输入中读取dockerfile进行构建"><span>从标准输入中读取Dockerfile进行构建</span></a></h3><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Dockerfile</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">或者</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">cat</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Dockerfile</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">|</span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，他没有上下文。因此不可能像其他方法那样可以将本地文件<code>COPY</code>进镜像之类的事情。。</p><h3 id="从标准输入中读取上下文压缩包进行构建" tabindex="-1"><a class="header-anchor" href="#从标准输入中读取上下文压缩包进行构建"><span>从标准输入中读取上下文压缩包进行构建</span></a></h3><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">build</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">-</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">context.tar.gz</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当发现标准输入的文件格式是：<code>gzip</code>、<code>bzip2</code>、以及<code>xz</code>的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>`,49))])}const D=l(k,[["render",o],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/linux/ge7ui8ae/","title":"06. 使用Dockerfile定制镜像","lang":"zh-CN","frontmatter":{"createTime":"2025/02/17 16:59:04","permalink":"/linux/ge7ui8ae/","title":"06. 使用Dockerfile定制镜像","description":"前言 刚开始使用的是docker commit在定制镜像。 镜像定制实际上就是定制每一层所添加的配置、文件。当我们把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题，镜像构建透明性的问题，体积的问题都会解决，这个脚本就是Dockfile Dockerfile是一个文本文件，其内包含了一条条的指...","head":[["meta",{"property":"og:url","content":"https://notes.moniter.top/linux/ge7ui8ae/"}],["meta",{"property":"og:site_name","content":"Richie Lin"}],["meta",{"property":"og:title","content":"06. 使用Dockerfile定制镜像"}],["meta",{"property":"og:description","content":"前言 刚开始使用的是docker commit在定制镜像。 镜像定制实际上就是定制每一层所添加的配置、文件。当我们把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题，镜像构建透明性的问题，体积的问题都会解决，这个脚本就是Dockfile Dockerfile是一个文本文件，其内包含了一条条的指..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06. 使用Dockerfile定制镜像\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"git":{},"autoDesc":true,"filePathRelative":"notes/linux/Kubernetes/Docker系列学习/Docker系列学习-06.使用Dockerfile定制镜像.md"}');export{D as comp,y as data};
